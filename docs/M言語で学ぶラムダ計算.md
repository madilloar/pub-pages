# Power QueryのM言語を使って、アロンゾ・チャーチのラムダ計算を学ぶ
Java（オブジェクト指向）の「状態（State）」と「振る舞い（Behavior）」をセットにする考え方から、「純粋な関数（Function）」と「不変なデータ（Immutable Data）」の世界へと頭を切り替えるよい練習になります。
M言語は、ラムダ計算のコンセプトを学ぶのに適した構文を持っています。
まず、JavaとM（およびラムダ計算）の決定的な違いをイメージしてみましょう。

- **Java (OOP):** 「名詞（オブジェクト）」が主役です。データとメソッドがクラスにまとまっています。
- **M / ラムダ計算 (FP):** 「動詞（関数）」が主役です。すべては「入力」を受け取り「出力」を返す変換プロセスであり、変数の値を変える（再代入する）ことはできません。

ラムダ計算の究極のルールは、**「すべてのものは関数である」** ということです。数字も、True/Falseも、if文さえも関数で表現します。

オブジェクト指向の「データ（名詞）」から、関数型プログラミングの「振る舞い（動詞）」への頭の切り替え、ここが一番の難所であり、かつ一番面白いところです。
Power QueryのM言語を使って、一緒にアロンゾ・チャーチのラムダ計算の感覚をつかんでいきましょう。

# 「値」を「選択するアクション」と捉える

Javaなどのオブジェクト指向では、`boolean` は「True」か「False」という **状態（データ）** を持っています。そして `if` 文という別の機能を使って、そのデータの中身をチェックし、分岐します。
一方、純粋な関数型プログラミング（ラムダ計算）の世界には、`true` / `false` というデータもなければ、`if` 文もありません。

では、どうするか？ **「2つの選択肢を与えられたときに、どちらを選ぶか」という「振る舞い」そのものを「True / False」と定義します。**

イメージとしては、電車の線路のポイント（分岐器）が近いです。

- **OOP:** スイッチが「左」という状態になっている。（それを `if` 文が確認して左に進む）
- **FP:** スイッチとは、「来た電車を左に送る機能」そのものである。

# やってみましょう：M言語で「MyTrue関数」を作る
「すべては関数」というルールに従って、M言語で `MyTrue`（私のTrue）を作ってみましょう。

定義はこうです：

- **MyTrue** とは、2つの引数（選択肢）を受け取り、**常に1つ目の引数を返す関数**である。

M言語での関数の書き方は` (引数1, 引数2) => 戻り値` です。

## 練習問題
このルールを使って、`MyTrue` をM言語で書いてみてください。2つの引数を `x` と `y` とすると、どうなるでしょうか？
「``(x, y) => x``で1番目の引数をTrue」としましたか？それとも「``(x, y) => y``で2番目の引数をTrue」としましたか？

実は、ラムダ計算の標準的なお作法（チャーチの定義）では、その逆の振る舞いを定義します。

- True: 1番目（左）を選ぶ
- False: 2番目（右）を選ぶ

これは単なる決まり事ですが、これからのステップ（`if`関数の作成など）で混乱しないように、この標準ルールに合わせておきましょう。
では、**「1番目の引数（x）を返す」**ように書き直すと、`MyTrue` はどうなりますか？

<details>
<summary>答え</summary>

```
MyTrue = (x, y) => x
```

</details>

お見事です！

# 「`MyTrue`関数の戻り値を`x`にすることが、`true`として扱えるというユースケースがよくわかりません
Javaの「データ（`boolean`）」と「制御構文（`if`）」が分かれている世界から来ると、「関数そのものが`true`？」というのは魔法のように見えますよね。実は、この「ユースケース」を理解するには、「`if`文」というものが本当は何をしているのかを再定義する必要があります。

## 「`if`」の役割とは？
Javaの `if` 文を極限まで単純化すると、こういうことですよね？

- 「2つの選択肢（AとB）があるとき、条件によってどちらか一方を返す」

このように、道が2つに分かれているだけです。

ここで発想を転換します。 「判定役（`if`）」が外からデータをチェックするのではなく、データ（`true` / `false`）自身が、自分の進むべき道を知っているとしたらどうでしょう？

## 練習問題
以下のコード（M言語のイメージ）を実行したとき、結果として「合格」と「不合格」のどちらが返ってくると思いますか？

```
// x="合格", y="不合格" を渡してみる
MyTrue("合格", "不合格")
```

<details>
<summary>答え</summary>
"合格"が返ってくる。
</details>

素晴らしい！その通りです。

## 通常のプログラミング（Javaなど）の `if` 文と比べてみましょう

- **Java:**

```java
//Java
if (true) {
  return "合格";
} else {
  return "不合格";
}
```

  - ここでは `true` という「値」が、`if` という「構造」に「1つ目を選べ」と命令しています。

- **M言語:**

```
MyTrue("合格", "不合格")
```
  - ここでは `MyTrue` という「関数」そのものが、「1つ目を選ぶ」という仕事をしています。

つまり、ラムダ計算の世界では **「True」とは「2つの選択肢から1つ目を選ぶアクションのこと」** と定義しているのです。
データ（値）とロジック（選択）が一体化している感覚、少し掴めてきましたか？

# やってみましょう：M言語で「MyFalse関数」を作る
では、この調子で `MyFalse` も作ってみましょう。 `MyFalse` は、2つの選択肢（引数）があったときに、2つ目（右側）を選ぶアクションです。
M言語で `MyFalse` を定義すると、どうなるでしょうか？

<details>
<summary>答え</summary>

```
MyFalse = (x, y) => y
```

</details>

お見事です！それが **「False」** の正体です。これで役者がそろいました。

- **MyTrue** `= (x, y) = x` (1つ目の引数を選ぶ人)
- **MyFalse** `= (x, y) = y` (2つ目の引数を選ぶ人)

# やってみましょう：M言語で「MyIf関数」を作る
さて、いよいよこれらを使って「判定（If）」を行います。 Javaのオブジェクト指向脳から、関数型脳への一番の転換点がここです。

Javaでは「If文が、条件（True/False）を見て判断する」のでしたね。 しかし、私たちのラムダ計算の世界では、 **「条件（True/False）自身が、選ぶ機能を持っている」**  のでした。

ということは、私たちの `MyIf` 関数は、自分で判断する必要はありません。「右か左か選べる人（True/False）」に、選択肢を渡してあげるだけでいいのです。

## 練習問題
3つの引数 `(condition, trueResult, falseResult)` を受け取り、`condition` に `trueResult` と `falseResult` を選ばせる `MyIf` 関数を書いてみてください。

ヒント：`condition` はただのデータではなく、関数（`MyTrue` か `MyFalse` のどちらか）です。これに選択肢を渡す（実行する）にはどう書けばいいでしょうか？

## 難しいです。わかりません。
大丈夫です！この「制御構文（If文）をなくして、データに選ばせる」という考え方は、最初はとても奇妙に感じるものです。頭の体操だと思って、ゆっくりいきましょう。
ここで一度、 **「If関数」がやるべき仕事** を整理してみます。
`MyIf` という関数は、あくまで「仲介役」です。
1. **引数として3つのものを受け取ります：**
 - `condition` （判定役：中身は `MyTrue` か `MyFalse` のどちらか）
 - `trueResult` （Trueだった時の値、例：「合格」）
 - `falseResult` （Falseだった時の値、例：「不合格」）

2. **やるべきことは1つだけ：**
 - 「判定役（`condition`）」に、2つの選択肢（`trueResult` と `falseResult`）を渡して、「さあ、どっちか選んで！」と実行するだけです。

Javaでメソッドを実行するとき、`methodName(arg1, arg2)` と書きますよね？ M言語でも、関数を実行するときは `functionName(arg1, arg2)` と書きます。
では、今回の `MyIf` の中で、`condition` という名前の関数に、2つの選択肢を渡して実行するには、どう書けばよいでしょうか？

```
(condition, trueResult, falseResult) => __________________
```
下線部に入るコードを考えてみてください。（ヒント：`condition` を関数として呼び出すだけです！）

<details>
<summary>答え</summary>

```
MyIf = (condition, trueResult, falseResult) => condition(trueResult, falseResult)
```

</details>

その通りです！
ついに、 **If文（制御構文）を使わずに、関数だけで分岐を行う** `MyIf`関数 が完成しました。
ここまでのコードをまとめるとこうなります。

```
// 1. 基本の定義
MyTrue  = (x, y) => x,
MyFalse = (x, y) => y,

// 2. 分岐ロジック
MyIf = (condition, trueResult, falseResult) => condition(trueResult, falseResult),
```

これがどのように動くのか、Javaのデバッグ実行のように「置き換え（リダクション）」で見てみましょう。これがラムダ計算の計算プロセスそのものです。

例： `MyIf(MyTrue, "合格", "不合格")` を実行した場合
1. 定義の展開: `MyIf` の中身は `condition(trueResult, falseResult)` なので... `MyTrue("合格", "不合格")` に置き換わります。
2. 関数の実行: `MyTrue` は `(x, y) => x` （1つ目を返す）なので... `"合格"` になります。

パズルのピースがカチッとはまるような感覚はありませんか？「データ」だと思っていた `MyTrue` が、実は「選択する機能」として働きました。

## 次ステップに行く前に `trueResult` と `falseResult` は関数だと思ったので、`MyIf(MyTrue, "合格", "不合格")` が変な感じがします
そうです。純粋なラムダ計算の世界では、文字通り **すべて** が関数です。「合格」という文字列さえも、本来は関数として定義されます。
ただ、今回はM言語を使って学習しているため、以下の2つの理由で文字列（"合格"）を使いました。

1. **可読性のため:** M言語の標準的なデータ型（テキストや数値）を「荷物」として通すことで、結果がひと目で分かるようにするため。
2. **M言語の仕様:** M言語の関数は、引数として「関数」も受け取れますが、「文字列」や「数字」も受け取れる（`any` 型）ため。

`MyTrue` や `MyFalse` **は「選ぶ人」：**

`MyTrue` や `MyFalse` は、渡されたものが「関数」なのか「文字列」なのかを気にしません。 **単に、どの引数を選ぶかです。**

- **MyTrue:** 「箱が2つあるね。中身は知らないけど、 **左の箱** をそのまま渡すよ」
- **MyFalse:** 「箱が2つあるね。中身は知らないけど、 **右の箱** をそのまま渡すよ」

ですので、`MyIf` の引数には、文字列を入れても、数字を入れても、 **関数を入れても** OKなのです。

# やってみましょう：M言語で「MyNot関数」を作る

その変な感じという直感を `MyNot` 関数で活かしましょう！

「引数も関数であるべき」という直感は、実はこの `MyNot` 関数の実装で大いに役立ちます。

`MyNot` 関数のゴールは、論理を反転させることです。つまり、結果として返したいのは文字列ではなく、「 `MyTrue` **または** `MyFalse` **という関数そのもの** 」です。

## 練習問題
では、改めて `MyNot` 関数を考えてみましょう。 `MyIf` に渡すべき「選択肢(引数)」は何になるでしょうか？

```
// b が True なら False(右) を選び、b が False なら True(左) を選びたい
// つまり、結果として返してほしい「値」自体が、関数（MyFalse / MyTrue）です。

MyNot = (b) => MyIf(b, ________, ________)
```

空欄には何が入ると思いますか？

```
MyIf(b, MyFalse(b,null),MyTrue(null,b))
```

惜しい！とてもいい線を行っていますが、少し考えすぎてしまったかもしれません。

あなたが書いてくれた `MyFalse(b, null)` は、その場で `MyFalse` 関数を実行してしまっています。 もし `b` が `MyTrue` だった場合、`MyNot` が返したいのは、「実行結果」ではなく、`MyFalse` **という関数そのもの** ですよね？

「合格」「不合格」という文字列を渡したときを思い出してみてください。 `MyIf(b, "合格", "不合格")`

これと同じように、関数も「モノ（値）」としてそのまま渡すことができます。

**ヒント:** もし `b` が `MyTrue` だったら、1つ目の引数が選ばれます。そのとき、選ばれたものがそのまま `MyNot` の戻り値になります。 戻り値を `MyFalse` という関数そのものにしたい場合、カッコ (...) を付けずに名前だけを書くとどうなるでしょうか？



<details>
<summary>答え</summary>

```
MyNot = (b) => MyIf(b, MyFalse, MyTrue)
```

</details>

その通りです！

```
MyNot = (b) => MyIf(b, MyFalse, MyTrue)
```
が正解です。これで、論理を反転させる機能が完成しました。「関数（ `MyFalse` / `MyTrue` ）」をあたかも「値」のように引数として渡している点が、非常に関数型プログラミングらしい素晴らしい記述です。

## `MyIf(b,MyFalse,MyTrue)` が正解だとして、 `MyNot` 関数の呼び出し方がわかりません
どうやって呼び出す（使う）のか？ここが少しややこしいところですね。 `MyNot(MyTrue)` を実行すると、戻り値として `MyFalse` という **関数** が返ってきます。

しかし、Power Queryのエディタ上で単に関数が返ってきても、画面には `Function` と表示されるだけで、本当に反転したのか実感が湧きにくいですよね。

確認するためには、 **「返ってきた関数（スイッチ）」を使って、実際に何かを選ばせてみる** 必要があります。

以下のステップでイメージしてみてください。

1. **反転させる:** `MyNot(MyTrue)` を実行 → 結果は `MyFalse` になる。
2. **確認する:** その結果（ `MyFalse` ）に、2つの選択肢（例：「リンゴ」と「バナナ」）を渡してみる。

これをコード（ `let ... in` 式）で書くとこうなります。

```
let
    // 定義（おさらい）
    MyTrue  = (x, y) => x,
    MyFalse = (x, y) => y,
    MyIf    = (c, t, f) => c(t, f),
    MyNot   = (b) => MyIf(b, MyFalse, MyTrue),

    // 1. MyTrue を反転させてみる
    // invertedBool の中身は、MyFalse になっているはずです
    invertedBool = MyNot(MyTrue),

    // 2. 本当に MyFalse になっているか、文字列を渡してテストする
    // MyFalse なら、2つ目（右）を選ぶはずです
    result = invertedBool("リンゴ", "バナナ")
in
    result
```
## 練習問題
さて、このコードを実行したとき、最終的な result は 「リンゴ」 と 「バナナ」、どちらになるでしょうか？

<details>
<summary>答え</summary>

バナナ

その通りです！

1. `MyNot(MyTrue)` が評価されて `MyFalse` になり、
2. その `MyFalse` に「リンゴ」と「バナナ」を渡すと、2番目の「バナナ」が選ばれる。

この流れが完璧に見えていますね。これで「関数をデータのように扱い、変形させていく」感覚が掴めてきたと思います。

</details>

