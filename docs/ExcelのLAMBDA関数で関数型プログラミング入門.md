章立て原案

#### **第1章：関数は「値」である —— 第一級関数（First-Class Functions）**

**【概念】** 関数を数値や文字列と同じ「データ」として扱う。
**【Excelでの実装】**

* **従来の常識：** 数式はセルに書くもの。
* **FPの常識：** 関数はセルに入れられる値であり、変数（名前）に代入できる。
* **実践：**
* セルA1に `=LAMBDA(x, x*2)` という「関数そのもの」を入力する。
* セルB1で `=A1(10)` と呼び出す。
* これにより、**「関数も単なるデータ（値）に過ぎない」** ことを体感する。


* **解説：** これが「第一級市民（First-Class Citizen）」としての関数。これができないとFPは始まらない。

#### **第2章：関数を生産する工場 —— カリー化（Currying）と部分適用**

**【概念】** 多引数関数 `f(x, y)` を、1引数関数の連鎖 `f(x)(y)` に変換する。
**【Excelでの実装】**

* **従来の常識：** `=SUM(A1, B1)` のように引数はカンマで区切る。
* **FPの常識：** 関数は一度に1つの引数しか受け取らない（純粋なラムダ計算の模倣）。
* **実践：**
* **「足し算メーカー」を作る：**
`=LAMBDA(x, LAMBDA(y, x+y))`
* **部分適用（Partial Application）：**
`ADD_10 = 足し算メーカー(10)` という関数を動的に生成する。
`ADD_10(5)` → 15


* **解説：** なぜカリー化するのか？ それは「特定の機能を持った専用関数」を量産するため（DI：依存性の注入に近い考え方）。

#### **第3章：関数を引数に取る関数 —— 高階関数（Higher-Order Functions）**

**【概念】** データではなく「ロジック（関数）」を引数として受け取る。
**【Excelでの実装】**

* **実践：** ここで初めて `MAP` 関数が登場しますが、使い方の解説ではありません。
* **実験：**
* 第2章で作った `ADD_10`（関数）を `MAP` に渡す。
* `=MAP({1,2,3}, ADD_10)`


* **比較：**
* `=MAP({1,2,3}, LAMBDA(x, x+10))` と書くのと、
* `=MAP({1,2,3}, ADD_10)` と書くのの違い。
* 後者（ポイントフリースタイルに近い記述）の美しさと再利用性について。



#### **第4章：関数の合成（Composition）とパイプライン**

**【概念】** 小さな関数をつなぎ合わせて、大きな処理を作る `f(g(x))`。
**【Excelでの実装】**

* **課題：** Excelの数式は `FUNC_A(FUNC_B(x))` のように内側から外側へ読むため、ネストが深くなると読みづらい。
* **実践：** `REDUCE` を使って「関数合成（COMPOSE）」を自作する。
* 関数のリスト `{FUNC_A, FUNC_B, FUNC_C}` を `REDUCE` で畳み込み、順次適用していく「パイプライン処理」を実装する。


* **解説：** データがベルトコンベア（関数のパイプライン）を流れていくイメージ。UNIXのパイプ `|` と同じ思想。

#### **第5章：状態を持たないループ —— 再帰（Recursion）と末尾再帰**

**【概念】** ループ変数（可変状態）を排除し、関数の呼び出し構造だけで繰り返しを表現する。
**【Excelでの実装】**

* **実践：**
* リストの処理を `MAP` に頼らず、カリー化された再帰関数で実装する。
* 「リストの先頭（Head）」と「残り（Tail）」に分割し、処理していくLisp的なアプローチ。


* **解説：** 宣言的記述の極致。なぜ再帰は美しいのか、そして「スタックオーバーフロー」という物理的限界について。

#### **最終章（番外編）：不動点コンビネータ（Y/Z Combinator）**

**【概念】** 名前（再帰定義）がない環境で再帰をするための理論。
**【Excelでの実装】**

* **実践：** 第2章で学んだ「カリー化」がここで活きる。
* 引数が1つの関数しか扱えない純粋なラムダ計算の世界で、いかにして階乗を計算するか。
* `LAMBDA(f, LAMBDA(x, f(x*x)))` のような高階関数の極致を体験する。

---

# Excelで「関数型脳」を作る Vol.1：世界は書き換わらない —— 「代入」から「定義」へ

プログラミングを始めたばかりの中学生の頃、どうにも理解に苦しむ謎の式がありまして、

```java
x = x + 1;
```

です。**「両辺から `x` を引いたら `0＝1` になるじゃん、なんだこれ？！」** と。

プログラミングの本を読みあさると、「これは方程式ではなく、**代入** という箱の中身を書き換える命令である」と。
「そういうものか」と飲み込んで数10年、`i++` を書きまくってきました。
今更ですがExcelに搭載された **LAMBDA関数** に出会い、再びあの頃の感覚がよみがえってきました。

**「あれってやっぱりおかしかったんだ」**

第1回のテーマは、 **「名前」と「不変性」** についてです。
※全部で5,6回の投稿になりそうです。

---

## 1. 「箱」に入れるか？、「名前」を付けるか？ それが問題だ。

命令型プログラミングで `x = x + 1` の代入を許していたのは、CPUとメモリをバスでつなげる、機械の都合に合わせた命令型プログラミングスタイルをそのまま踏襲して、 **「値を出し入れできる箱」** として **変数** を生み出したからと考えています。

* **命令型プログラミングの世界：**

```java
x = 10;
x = x + 1;
```

を読み下すと、

* `x` という箱があり、中身は10。
*  そこから10を取り出し、1を足して11にし、もう一度箱 `x` に戻す（再代入）。

命令型プログラミングの世界では、時間経過とともに、`x` は **変化します** 。

一方で、関数型プログラミングのアプローチは全く異なり、変数は「箱」ではありません。 **「値につけられた名前」** です。
というか、 **変数** というのもおかしな話で、 **変化しない** です。

* **関数型プログラミングの世界：**

```java
x = 10;
y = x + 1;
```

を読み下すと、

* `10` という値がある。これに `x` という **名前を定義** します。
* `11` が必要なら、`x` を **書き換えない** 。 `x + 1` という新しい値を用意し、それに `y` という **新しい名前を付ける** 」です。

一度「 `x` は `10` である」と **定義（束縛：Bind）** したら、その世界の中で `x` が `11` に変わることはないです。
これが **「不変性」** です。

---

## 2. Excelは「定義」の集まり

この「一度決まったら変わらない」という感覚は、 **Excelのシートそのもの** です。

セル `A1` に `10` と入力し、 `B1` に `=A1+1` と入力します。
`B1` の結果は `11` です。
このとき、A1の値は **書き換わりません** 。 `A1` は `A1` のまま、 `B1` は新しい値として存在します。

**「 `A1`とは `10` のことである」「 `B1` とは `A1` に `1` を足したものである」** と、事実を **定義** しているだけです。
Excelで数式を使っている時は、そもそもセルに対して「書き変えろ」と命令したくてもできません。
Excelは、LAMBDA関数が登場する以前から、数式に **名前定義** する機能があり、セルを書き換えることができない **不変性** を持っていたのが、改めて考えさせられます。

---

## 3. 何回テストしても同じ結果になるうれしさ！

「名前の中身が絶対に書き換わらない」ので、**「入力が同じなら、出力は絶対に同じになる」** というルールが徹底される点がうれしいです。
何回テストしても同じ結果になる！！

---

## 4. ループ変数 `i` を捨ててどうするか？

とはいえ、実務ではループ処理が必要で、「変数を書き換えられない（再代入できない）のに、どうやって `1` から `10` まで合計する？」とかです。
ここで目から鱗だったのは、 **「変数を変化させる」のではなく、「新しい値を生成する」** です。

命令型脳の私はこう考えていました。

* ループ変数`i` と合計用変数 `sumVal` を用意して、 `for` 文で `i` を `1` から `10` まで回して...と、どんな命令をどんな順番で動かしてと考えていました。

```java
int sumVal = 0;
for(int i = 1; i <= 10; i++) {
  sumVal += i;
}
```

ここには、時間経過とともに変化する `i` と `sumVal` と、`i` を **繰り返す命令** と **合計する命令** です。
※この文脈なら、 **命令** より **文** の方がふさわしいか？！

関数型脳で考えると、

* 数列を生み出す `SEQUENCE` 関数で、`1` から `10` までの数列を生成する。
* その数列を `SUM` 関数で合計する。

```excel
=SUM(SEQUENCE(10))
```

ここには、時間経過とともに変化する `i` はなく、あるのは、数列を生み出す **関数** と数列を合計する **関数** です。

---

## 「名前定義」は「日本語」でいい。ユビキタス言語の実践

一般的なコーディング規約では、 **変数名はASCIIであること** が常識ですが、Excelでは忘れてもよいと思っています。
例えば、今、業務ロジックを記述しているとします。顧客側の現場担当者が「売上総利益」と呼んでいるものを、コードの中で `GrossMargin` とか `UriageSouRieki` と翻訳するのは認知負荷（脳のメモリ消費）がかかるので、メンドクサイです。

**「現場で使われている言葉（ユビキタス言語）を、そのまま数式の中で使う」**
でいいじゃないですか。Excelなんだし。

### メンドクサイ例：

```excel
=LET(x, A1, y, 0.1, x * y)
```

「認知負荷高っ！」半年後にこのコードを見たら、「 `x` って何？  `y` って何？」となります。

### 一般的なコーディング規約例：

```excel
=LET(priceVal, A1, taxRate, 0.1, price * taxRate)
```

```excel
=LET(kakakuVal, A1, shouhiZeiRate, 0.1, kakakuVal * shouhiZeiRate)
```

これでも認知負荷が高いなぁ。。。

### 最良の例：日本語（ユビキタス言語）

```excel
=LET(_定価, A1, _消費税率, 0.1, _定価 * _消費税率)
```

でいいじゃないですか。数式がそのまま「文章」として読めるし。
Excelの数式エンジンは、日本語（Unicode）の **名前定義** をサポートしているので、どんどん使いましょう。

### ちょい足しコーディング規約：名前の接頭辞に「アンダースコア」を付ける

日本語を使う際、ちょい足しコーディング規約をしたいです。
それは、名前の先頭に **`_`（アンダースコア）** を付けることです。

* `_定価`
* `_消費税率`

これは **入力支援（インテリセンス）:** 数式バーで `_` を入力すると、自分が定義した日本語の名前だけが候補に表示されるので、矢印キーで選べるのが便利だからです。
Excelの標準的な関数は英字名なので、関数名を入力した後に、名前を入力する際に、日本語IMEを起動して名前を入力して、また、日本語IMEをOFFにしてと行き来するのがメンドクサイのを防止するためです。
IDEによる支援がもっと強力になれば変わってくるのでしょうが、とりあえず、これをするだけでもだいぶ楽になります。

---

## 5. まとめ：代入をやめ、名前を定義しよう

「x=x+1」に感じたあの違和感のまま進められれば、関数型脳になれたのになぁと。
命令型脳にどっぷりとつかってきたので、プログラミングとは、命令して変数を書き換えまくること（代入）に慣れすぎてしまいました。
Excel LAMBDA関数に親しんでいくと、 **「値に名前を付け（定義）、事実を積み上げていく」** という新しいプログラミングスタイルの面白さがでてきました。

* **命令型:** 箱の中身を入れ替える（代入）。
* **関数型:** 値に名前を付ける（定義）。

ここまでで、「数値」や「文字列」が値であり、それに名前を付けられることが理解できるようになりました。
で、関数型プログラミングでよく言われている、**「関数そのものも値** なら、当然 **関数にも名前を付けられる** ので、Excelでもできるのですが、
関数型プログラミングがわかっていない、命令型脳の私が、ちょっとしたタイプミスから、これに気づいたのが、これまた目から鱗でしたので、 **Vol.2「関数は値だった」** へ続きます。

---

### 今日の気づき

*  （代入）が気持ち悪いのは正常な感覚だった。
* プログラミングは「書き換え」ではなく「定義（名前付け）」の連続である。
* 定義する名前には、現場の言葉（日本語）と `_` を使うのがベストプラクティスである。

---

# Excelで「関数型脳」を作る Vol.2：実験、関数は「値」なのか？

前回、私は  という式への違和感から、「変数は箱ではなく、値につける名札（定義）だ」という事実にたどり着きました。
この「不変性」こそが、Excelの数式が堅牢である理由でした。

さて、関数型プログラミング（FP）の勉強を進めていると、必ず耳にする不思議な言葉があります。

**「関数型言語では、関数も『値（Value）』として扱える」**

正直、ピンときませんでした。
「値」といえば、`1` とか `"Hello"` のことです。
「関数」といえば、`SUM` や `VLOOKUP` のような、計算をしてくれる「機能」のことです。
この2つが同じって、どういうことでしょうか？

もしこの噂が本当なら、Excelでも**標準関数を「値」として扱える**はずです。
私は半信半疑のまま、ある実験をしてみることにしました。

第2章のテーマは、**「第一級関数（First-Class Functions）」**。
Excelがただの表計算ソフトを超えた瞬間を目撃します。

---

## 1. 実験：SUM関数に「あだ名」を付けてみる

「関数が値である」とは、具体的には**「変数（名前）に関数を入れられる」**ということです。
数値の `10` を `x` という名前に定義できるなら、`SUM` という関数も `_mySum` みたいな名前に定義できるはずです。

VBAの常識で言えば、そんなことは不可能です。`SUM` はキーワードであり、オブジェクトではないからです。

しかし、LAMBDAを搭載した今のExcelなら……？
私は `LET` 関数を使って、禁断の数式を入力してみました。

```excel
=LET(
    _合計, SUM,        // SUM関数そのものを「_合計」という名前に定義！
    _合計(B1:B3)       // その名前を使って計算
)

```

「まあ、さすがにエラーになるだろうな。`SUM` は機能であって、データじゃないし……」

そう思いながらエンターキーを押した瞬間。
セルには、B1:B3の合計値が表示されました。

**「えっ、動いちゃった！？」**

エラーどころか、完璧に計算されています。
`SUM` という機能が、`_合計` という名前にそっくりそのまま移譲されました。

---

## 2. 関数は「特別」じゃなかった

この実験結果が意味することは重大です。

1. `SUM` という**Excel標準の機能**を、
2. `_合計` という**「名前」**に定義（束縛）し、
3. その `_合計` に引数を渡して実行できた。

これって、`10` という数値を `x` という名前に定義するのと、何が違うんでしょうか？
**何も違いません。**

Excelの世界では、`1` も `"Hello"` も、そして `SUM` や `VLOOKUP` さえも、等しく**「名前を付けられるデータ（値）」**に過ぎなかったのです。

「関数はプログラムの中に固定された装置」だと思っていたのは、私の思い込みでした。
Excelにとって関数は、セルに入れて持ち運んだり、好きな名前を付けたりできる、ただの**「道具（値）」**だったのです。

この「関数を特別扱いせず、数値や文字列と同じように扱える」性質を、専門用語で **「第一級関数（First-Class Functions）」** と呼ぶそうです。
「関数もファーストクラス（一等市民）の待遇を受けている」という意味ですね。

---

## 3. 自作関数（LAMBDA）も「値」になる

「標準関数が値なら、私が作った計算ロジック（LAMBDA）も当然、値になるはずだ」

前回作った「2倍にする計算」を `_二倍` という名前に定義してみます。

```excel
=LET(
    _二倍, LAMBDA(x, x * 2),   // LAMBDAで作った関数を名前に定義
    _二倍(10)                // その名前を使って計算
)

```

結果は `20`。当然のように動きます。

ここで重要な事実に気づきました。
`SUM` も `LAMBDA` も、扱われ方は全く同じです。
どちらも**「機能を持った値」**であり、私たちはそれに**「名前を付けている（定義している）」**だけなんです。

---

## 4. 関数を「引数」として渡してみる（高階関数の萌芽）

「関数が値なら、もしかして……**関数の引数として『別の関数』を渡す**こともできるのでは？」

これができれば、プログラミングの世界が一変します。
実験してみました。

「ある関数 `_f` と、数値 `_x` を受け取り、2回実行する関数」を作ってみます。

```excel
=LET(
    // 1. 引数として関数(_f)を受け取る関数を定義
    _二回適用, LAMBDA(_f, _x, _f(_f(_x))),

    // 2. 渡すための関数（プラス1くん）
    _プラス1, LAMBDA(n, n + 1),

    // 3. 実行：関数(_二回適用)に、関数(_プラス1)を渡す！
    _二回適用(_プラス1, 10)
)

```

頭がこんがらがりそうですが、トレースしてみます。

1. `_二回適用` の引数 `_f` として、`_プラス1` という**ロジックそのもの（値）**が定義されます。
2. 中で `_プラス1(_プラス1(10))` が実行されます。
3. 10 → 11 → 12。

結果は `12`。成功です！

これが何を意味するか分かりますか？
これまでの私は、関数の中にロジックをガチガチに書き込んでいました。
しかし、この「関数を値として渡す」テクニックを使えば、
**「処理の枠組み（2回やる）」だけを作っておき、「中身の処理（足す、掛ける…）」は後から部品として渡せる** のです。

---

## 5. まとめ：関数は「道具」であり「材料」である

「関数型言語では関数も値である」
この噂は本当でした。それどころか、普段使い慣れた `SUM` 関数ですら、ただの値の一つに過ぎなかったのです。

* **Before:** 関数は、固定された「機能」だった。
* **After:** 関数は、名前を付けて持ち運べる「値（材料）」になった。

関数を「値」として扱えるようになると、ある野望が生まれます。
「関数に関数を渡せるのは分かった。じゃあ、**関数が『新しい関数』を産み落として返す**こともできるのでは？」

もしそれができれば、「足し算関数」から「10を足す専用関数」を自動製造する工場が作れるはずです。
次回、**第3章「カリー化と部分適用」**。
ここから一気に、パズルが複雑で面白くなってきます。

---

### 今日の気づき

* `SUM` などの標準関数も、そのまま `LET` で名前に定義できる。
* つまり、Excelにとって関数は「値」そのものである。
* 関数を引数として渡すことで、ロジックを部品として扱えるようになる。これが「第一級関数」である。

---

# Excelで「関数型脳」を作る Vol.3：関数を生み出す工場 —— カリー化と部分適用

前回、私は「関数は値である」という事実に気づきました。
関数を名前（変数）に入れたり、引数として渡したりできる。これは大きな発見でした。

そこで、ふと新たな疑問が湧いてきます。
「関数を引数として『渡せる（Input）』なら、逆に関数を戻り値として**『返せる（Output）』**んじゃないか？」

もしそれができれば、**「関数を作り出す関数（Function Factory）」** が作れるはずです。
そして、その技術こそが、私が抱えていた「ある悩み」を解決する鍵でした。

第3章のテーマは、**「カリー化（Currying）」と「部分適用（Partial Application）」**。
ちょっと難しそうな名前ですが、要は**「便利な専用ツールを自動生成するテクニック」**のことです。

---

## 1. 毎回、引数を指定するのが面倒くさい

実務でよくあるシーン、消費税計算で悩んでいました。
「税抜価格」から「税込価格」を計算したいのですが、税率には 10% と 8%（軽減税率）があります。

普通に LAMBDA を書くとこうなります。

```excel
=LET(
    _税込計算, LAMBDA(_価格, _税率, _価格 * (1 + _税率)),
    
    // 使うたびに「税率」を指定しないといけない…面倒！
    _Aさん, _税込計算(1000, 0.1),
    _Bさん, _税込計算(500, 0.08),
    _Cさん, _税込計算(2000, 0.1)
)

```

これ、書いていてイライラします。
ほとんど 10% なのに、毎回 `0.1` と書かないといけない。もし税率が変わったら、シート中の `0.1` を全部書き直しです。

「10%専用の関数」と「8%専用の関数」があらかじめ用意されていれば、もっとミスなく書けるはずです。
**「引数を1つ（税率）だけ先に渡しておいて、『あとは価格を入れるだけ』の状態にした関数を作れないか？」**

---

## 2. マトリョーシカのような関数

そこで思いついたのが、前回学んだ「関数は値である」という事実です。
値なら、`LAMBDA` の戻り値として返すこともできるはずです。

「よし、LAMBDAの中に、もう一つLAMBDAを入れてみよう」

```excel
=LAMBDA(_税率, 
    LAMBDA(_価格, _価格 * (1 + _税率))  // ← 内側の関数を「値」として返す！
)

```

この構造を頭の中でシミュレーションしてみました。

1. 外側のドアを開けて `_税率` (0.1) を渡す。
2. すると、計算結果ではなく、**「`_価格` を受け取って計算する関数」** がコロンと出てくる。
3. その出てきた関数に `_価格` (1000) を渡す。

このように、多引数の関数を「引数が1つの関数の連鎖（入れ子）」に変換することを、**「カリー化（Currying）」** と呼びます。
考案者のハスケル・カリーさんの名前に由来するそうです（カレーライスとは関係ありません）。

---

## 3. 「専用関数」の量産に成功（部分適用）

では、この「工場」を使って、実際に動くか実験です。

```excel
=LET(
    // 1. 税率を受け取ると、「価格を受け取って計算する関数」を返す工場
    _税込計算工場, LAMBDA(_税率, 
        LAMBDA(_価格, _価格 * (1 + _税率))
    ),

    // 2. 工場を稼働させて、専用関数を作る（これを「部分適用」と呼ぶ）
    _標準税率で計算, _税込計算工場(0.1),   // 10%版の関数が完成！
    _軽減税率で計算, _税込計算工場(0.08),  // 8%版の関数が完成！

    // 3. 現場では、専用関数を使うだけ！
    _標準税率で計算(1000)  // -> 1100
)

```

動きました！
使う側（3）のコードを見てください。劇的にシンプルになりました。

「今の税率はいくらだっけ？」と毎回気にする必要はありません。**「_標準税率で計算」という専用ツール**が既に手元にあるからです。
引数の一部（ここでは税率）を固定して、新しい関数を作り出すことを **「部分適用（Partial Application）」** と呼ぶそうです。

---

## 4. なぜ「工場」を作るのか？

「普通に `_標準税率計算` という関数を定義すればいいじゃないか」と最初は思いました。
しかし、カリー化の真価は **「変化に強い」** ことにあります。

もし将来、「消費税15%」の時代が来ても、工場に `0.15` を渡して `_新税率で計算` を作るだけ。ロジック本体を書き換える必要はありません。

また、このテクニックは「設定」と「処理」を分けるのにも役立ちます。

* **設定（マスタデータなど）：** 先に渡して固定しておく。
* **処理（トランザクションデータ）：** 後から流し込む。

この役割分担ができるようになると、数式の設計が驚くほどきれいになります。

---

## 5. まとめ：道具は揃った

最初は「カッコが増えて面倒くさい」と思ったカリー化。
しかし、その本質は **「汎用的なロジックから、専用の道具を切り出す」** ことにありました。

* **カリー化:** 引数を小分けにして渡せる構造（工場）を作ること。
* **部分適用:** 設定値を固定して、使いやすい専用関数（製品）を作ること。

これで、私は自分だけの「関数ライブラリ」を作れるようになりました。

さて、ここで作った「引数が1つだけの専用関数」。
実はこれこそが、**次章で紹介する「最強のデータ処理」に不可欠なピース**なのです。

「1つずつの計算はできた。じゃあ、**1万行のデータに対して、この『専用関数』を一気に適用したい**ときはどうする？」

forループ？ いいえ、もっといい方法があります。
次回、**第4章「高階関数（MAP / FILTER）」**。
Excelの配列数式が火を吹く瞬間を目撃してください。

---

### 今日の気づき

* 引数が多い関数は使いにくいし、設定値を何度も書くのはミスの元。
* `LAMBDA` を入れ子にすると、引数を1つずつ固定できる（カリー化）。
* これを使って「設定済みの専用関数」を作っておくと、後の作業が圧倒的に楽になる（部分適用）。
---

# Excelで「関数型脳」を作る Vol.4：脱・セル思考 —— テーブルを行単位で回す（MAP / BYROW）

前回、私はカリー化と部分適用を使って、「消費税10%計算専用の関数」を作ることに成功しました。
道具は揃いました。あとはこれを使って、目の前にある**1,000行のテーブル**を処理するだけです。

ここで、私は大きな壁にぶつかりました。
**「Excelの数式には、なぜ『Forループ』がないんだ？」**

VBAなら、`For i = 1 To 1000` と書いて、1行ずつ「単価×数量」を計算して書き込めます。
しかし、数式（LAMBDA）の中には繰り返し構文がありません。
「せっかく関数を作ったのに、1,000行の表を一行ずつ処理する命令が書けない……」

途方に暮れていた私が出会ったのが、**`MAP`** と **`BYROW`** でした。
それは、ループ回数を数えるのをやめて、**「レコード（行）という塊」**でデータを捉えるための魔法でした。

---

## 1. 複数列を「同期」させてループする

実務のデータは、1列のリストではありません。
A列に「単価」、B列に「数量」があるような**テーブル**です。

最初は「A列の計算をしてから、B列を掛けて……」と、これまでの「オートフィル（ドラッグ）」と同じ思考で悩んでいました。
しかし、調べてみると **`MAP` 関数は複数の配列を同時に受け取れる** ことが分かりました。

```excel
=LET(
    _単価列, A2:A10,
    _数量列, B2:B10,
    
    // 2つの配列を渡すと、LAMBDAも引数を2つ受け取れる！
    _売上リスト, MAP(_単価列, _数量列, 
        LAMBDA(_単価, _数量, _単価 * _数量)
    ),
    
    _売上リスト
)

```

「これだ……！」
VBAで `Cells(i, 1) * Cells(i, 2)` と書いていた処理が、数式だけで再現できました。
しかも、`MAP` は裏側で「1行目同士、2行目同士……」と自動で同期してループを回してくれます。

---

## 2. 行（レコード）を丸ごと渡す `BYROW` の衝撃

しかし、列が10個もあったらどうでしょう？
`MAP(_列1, _列2, ... _列10, LAMBDA(_a, _b, ... _j, ...))`
……これでは引数を書くだけで日が暮れますし、順番を間違えたら大惨事です。

私がやりたいのは、**「この『行（レコード）』を渡すから、あとは中身を見てよろしくやって！」** という丸投げです。

そこで見つけたのが **`BYROW`（バイ・ロウ）** です。
名前の通り、「行ごとに（By Row）」処理を行う関数です。

```excel
=LET(
    _売上テーブル, A2:C10, // [単価, 数量, 税区分] が入っている
    
    _結果, BYROW(_売上テーブル, 
        LAMBDA(_行, 
            // 「_行」には、ある1行分のデータ（1x3の配列）が丸ごと入ってくる
            ...さて、ここからどう取り出す？
        )
    )
)

```

ここで少し悩みましたが、解決策はシンプルでした。
**`INDEX` 関数** を使えば、渡された「行」の中から好きな列を取り出せます。

```excel
    _計算ロジック, LAMBDA(_行, 
        LET(
            _単価, INDEX(_行, 1), // 行の1列目
            _数量, INDEX(_行, 2), // 行の2列目
            _単価 * _数量
        )
    ),
    
    BYROW(_売上テーブル, _計算ロジック)

```

これこそが、私が求めていた**「レコード処理」**です。
「この範囲を行単位で回して、各行に対してこのロジックを適用せよ」。
手順（For文）を指示するのではなく、**「対象」と「ルール」を定義するだけ**で、1,000行の計算が一瞬で終わります。

---

## 3. 複数条件で `FILTER` する作法

計算（MAP/BYROW）ができるようになると、次は「特定の行だけ抽出したい」という欲求が湧きます。
実務の条件は複雑です。「東京都 **かつ** 売上1万以上」のように。

VBAなら `If ... And ...` ですが、数式の `FILTER` 関数の中で `AND` は使えません。
ここで私は、Excel独自の**「論理値の掛け算」**という作法に出会いました。

* **AND（かつ）**  `*` （掛け算）
* **OR（または）**  `+` （足し算）

```excel
=LET(
    _データ, A2:D100,
    _都道府県列, INDEX(_データ, , 1),
    _金額列, INDEX(_データ, , 4),

    // True(1) * True(1) = 1 (True) になる仕組み
    _条件, (_都道府県列 = "東京都") * (_金額列 >= 10000),

    FILTER(_データ, _条件)
)

```

「関数の結果（True/False）」もまた「値」であり、算術演算ができる。
この発見によって、複雑な抽出もパズルを解くように楽しくなりました。

---

## 4. 組み合わせる：絞り込んでから、計算する

では、これらを繋げてみましょう。
「在庫がある行だけを抜き出し、その行に対して税込計算を行う」というパイプラインです。

```excel
=LET(
    _マスタ, A2:C100, // [商品名, 単価, 在庫数]
    
    // 1. 絞り込み (FILTER)
    _対象, FILTER(_マスタ, INDEX(_マスタ, , 3) > 0),

    // 2. 行ごとの計算 (BYROW)
    _計算, BYROW(_対象, LAMBDA(_行, 
        INDEX(_行, 2) * 1.1
    )),

    _計算
)

```

中間データ（作業用のセル）を一切作らず、メモリの上だけで「抽出」から「計算」までが一瞬で完了しました。
これまでは「一度セルに書き出してから、隣の列で計算する」のが当たり前でしたが、**「データは書き出さずに、メモリの中で加工して繋ぐ」**という感覚が掴めてきました。

---

## 5. まとめ：データは「点」ではなく「面」で捉える

VBAで `Cells(i, j)` をいじっていた頃は、データを「点」で見ていました。
しかし、`BYROW` や `FILTER` を使いこなすと、データを「面（レコードの集合）」として捉えられるようになります。

* **MAP:** 複数の「列」を同期させて処理する。
* **BYROW:** 「テーブル全体」を渡し、行（レコード）単位でロジックを適用する。
* **FILTER:** 複数条件は `*` や `+` で「計算」して作る。

「繰り返し処理」の悩みは、もう消えました。
しかし、まだ最後の一枚、最も分厚い壁が残っています。

「計算結果をリストで出すのはできた。でも、最終的に欲しいのは、**その合計値（1つの値）** なんだよ！」
「前の行の計算結果を使って、次の行を計算したい（累積計算）ときはどうするの？」

これだけは、独立した行処理である `MAP` や `BYROW` では不可能です。
次回、最終章。
Excel関数型プログラミングの頂点にして最難関、**Vol.5「REDUCE（畳み込み）」**。
すべてのデータが一点に収束する魔法を目撃してください。

---

### 今日の気づき

* `MAP` は複数の列を同時に受け取れる。
* `BYROW` を使うと、テーブルの行（レコード）を丸ごとLAMBDAに渡せる。
* `FILTER` の複数条件は `AND` 関数ではなく、算術演算子（`*`や`+`）を使う。

次は、いよいよ「累積計算」と「集計」の王者、`REDUCE` に挑みます。
準備はいいですか？
---

# Excelで「関数型脳」を作る Vol.5：すべてを一つに —— 畳み込み（REDUCE / SCAN）と関数の合成

前回、私は `MAP` と `BYROW` を手に入れ、1,000行のデータを一瞬で計算できるようになりました。
VBAの `For` ループなんて、もういらない。そう思っていました。

しかし、実務のラストワンマイルで、再び壁にぶつかりました。
「計算はできた。で、その**合計**は？」
「**文字列を全部つなげて**、カンマ区切りのテキストを出して」

`MAP` は、100個のデータを入れたら、必ず100個の結果が返ってきます。
しかし今、私が欲しいのは、100個のデータを**「たった1つの値（合計や連結テキスト）」**に押し潰すこと。

そしてもう一つ。
「前の行の計算結果を使って、次の行を計算したい（累積計算）」
家計簿の「残高」のように、前の行の影響を受ける計算が、独立して動く `MAP` ではどうしても書けないのです。

そこで出会ったのが、ラスボスにして最強の兄弟関数、**`REDUCE`（リデュース）** と **`SCAN`（スキャン）** でした。

---

## 1. 雪だるま式に計算する `REDUCE`

`REDUCE` のマニュアルを読んでみましたが、最初は意味が分かりませんでした。

> **REDUCE(初期値, 配列, LAMBDA(累積値, 現在の値, ...))**

「減らす（Reduce）？ 何を？」
しかし、サンプルを動かしてみて、その正体が **「雪だるま作戦」** だと気づきました。

1. 最初に「雪玉の芯（初期値）」を用意する。
2. リストの要素を次々と巻き込んで、雪玉を大きくしていく（累積）。
3. 最後に、巨大になった雪玉（結果）を返す。

VBAで言うところの、これです。

```vba
Total = 0              ' 初期値
For Each x In List
    Total = Total + x  ' 累積値 = 累積値 + 現在の値
Next

```

これを数式で書くとこうなります。

```excel
=LET(
    _リスト, SEQUENCE(10), // 1, 2, ... 10
    
    // 雪だるま作戦開始
    _合計, REDUCE(
        0,           // 1. 雪玉の芯（初期値）
        _リスト,     // 2. 巻き込む材料（配列）
        LAMBDA(_累積値, _現在の値, 
            _累積値 + _現在の値 // 3. どうやって合体させるか？
        )
    ),
    _合計 // -> 55
)

```

「なんだ、ただの `SUM` 関数じゃないか」
そう思いましたか？ 私もそう思いました。
しかし、ここでふと疑問が湧きます。

**「途中の計算結果（雪だるまが大きくなっていく過程）も見たい時はどうすればいいんだ？」**

---

## 2. 過程をすべて記録する `SCAN`

例えば「銀行の残高」計算です。
入出金のリストがあって、知りたいのは「最終残高」だけじゃありません。「毎回の残高推移」が知りたいのです。

`REDUCE` は最後の1つしか返してくれません。
そこで登場するのが、双子の兄弟 **`SCAN`** です。

使い方は `REDUCE` と**完全に同じ**。違うのは出力だけです。

* **REDUCE:** 最終結果（1つの値）を返す。
* **SCAN:** 途中の計算結果すべて（配列）を返す。

```excel
=LET(
    _入出金リスト, {1000; -200; 500; -100},
    _開始残高, 10000,
    
    // REDUCE を SCAN に変えるだけ！
    _残高推移, SCAN(
        _開始残高,    // 初期値
        _入出金リスト, 
        LAMBDA(_現在の残高, _入出金, 
            _現在の残高 + _入出金  // 前の残高に足していく
        )
    ),
    
    _残高推移
)

```

結果はこうなります。

* 11000
* 10800
* 11300
* 11200

これまで「一番上のセルに数式を書いて、下までドラッグ（相対参照）」でやっていた累積計算が、たった一つの数式でスピル（展開）されました。
行の削除や挿入があっても、計算が壊れることはありません。

---

## 3. 文字列を自在に連結する

数値の計算なら `SUM` や累積和でなんとかなるかもしれません。
しかし、`REDUCE` の真価は、**「足し算以外」** をした時に発揮されます。

例えば、「リストの中身をカンマ区切りでつなげたい」。
`TEXTJOIN` 関数がありますが、「空文字は無視したい」とか「カッコで囲みたい」とか、条件が複雑になるとお手上げです。

`REDUCE` なら、**「合体のルール」** を自分でプログラムできます。

```excel
=LET(
    _単語リスト, {"りんご"; ""; "みかん"; "ぶどう"},
    
    _連結テキスト, REDUCE(
        "",           // 1. 初期値は空文字
        _単語リスト, 
        LAMBDA(_累積テキスト, _今の単語, 
            // もし単語が空なら、何もしない（累積値をそのまま返す）
            // 単語があるなら、カンマを付けてつなぐ
            IF(_今の単語 = "",
                _累積テキスト,
                _累積テキスト & "," & _今の単語
            )
        )
    ),
    _連結テキスト // -> ",りんご,みかん,ぶどう" （※先頭のカンマ処理は別途必要）
)

```

VBAで文字列操作をガリガリ書いていたあの処理が、たった一つの数式で完結しました。
**「前の状態（_累積テキスト）」** を受け取って、**「次の状態」** を返す。
このリレーをつなぐことができるのが `REDUCE` の正体だったのです。

---

## 4. 最終奥義：関数のパイプライン（合成）

さあ、いよいよ最後の伏線回収です。
Vol.3 で悩んでいた **「関数の合成」**。
複数の関数 `_f`, `_g`, `_h` をつなげて、パイプラインを作りたい。

実は、これも `REDUCE` で実現できるのです。
**「データ」に対して「関数のリスト」を次々と適用（累積）していけばいい** のです。

「データ」という雪玉を転がして、「関数」という坂道を次々と通過させるイメージです。

```excel
=LET(
    // --- 1. 部品となる関数たち（Vol.3で作ったカリー化関数など） ---
    _空白削除, LAMBDA(_値, SUBSTITUTE(_値, " ", "")),
    _大文字化, LAMBDA(_値, UPPER(_値)),
    _装飾,     LAMBDA(_値, "★" & _値 & "★"),
    
    // --- 2. 「関数のリスト」を作る ---
    // これがパイプラインの設計図になる！
    _処理パイプライン, VSTACK(_空白削除, _大文字化, _装飾),
    
    // --- 3. 実行したいデータ ---
    _元データ, " hello world ",
    
    // --- 4. REDUCEでパイプラインにデータを流す ---
    _結果, REDUCE(
        _元データ,         // 初期値：生データ
        _処理パイプライン,  // 配列：関数のリスト
        LAMBDA(_現在のデータ, _適用する関数, 
            _適用する関数(_現在のデータ)  // 関数を適用して、次の累積値にする
        )
    ),
    
    _結果 // -> "★HELLOWORLD★"
)

```

震えました。
`REDUCE` は、単に数値を足し合わせるだけの関数ではありませんでした。
**「データ」と「処理」を次々と衝突させ、新しい価値を生み出すエンジン** だったのです。

これなら、処理手順が増えても `_処理パイプライン` に関数を追加するだけ。
メインのロジックを修正する必要は一切ありません。

---

## 5. まとめ：Excelは「プログラミング言語」になった

Vol.1 から始まったこの旅。
最初は「 がおかしい」という小さな違和感から始まりました。

* **Vol.1:** 値に名前を付け（定義）、変数を不変にした。
* **Vol.2:** 関数もまた「値」であると知り、自由に持ち運んだ。
* **Vol.3:** 部分適用で、専用の道具を量産した。
* **Vol.4:** `MAP` と `BYROW` で、ループを使わずに世界を一括変換した。
* **Vol.5:** `REDUCE` と `SCAN` で、すべてを一つに統合した。

今、私の目の前にあるExcelシートは、かつての「表計算」とは別物です。
セルとセルの依存関係でスパゲッティになっていたロジックは消え、
**「入力」→「パイプライン」→「出力」** という、美しく堅牢なシステムの設計図に変わりました。

プログラミングとは、言語の文法を覚えることではありません。
**「データをどのように流し、どう変換するか」** を設計すること。
その本質を、Excel LAMBDA は教えてくれました。

さあ、あなたの番です。
そのセルの中に、あなただけの関数型脳をインストールしてください。
きっと、昨日までとは違う景色が見えるはずです。

**(完)**

---

### 今日の気づき

* `REDUCE` は「雪だるま式」に値を累積させ、最後の結果だけを返す。
* `SCAN` は `REDUCE` と同じ仕組みだが、途中の「成長過程（残高推移など）」をすべて返す。
* **「関数のリスト」を `REDUCE` することで、処理のパイプライン（合成）が完成する。**

---

# Excelで「関数型脳」を作る Vol.6：自分の尻尾を食べる蛇 —— 再帰呼び出し（Recursion）

前回、`MAP` と `REDUCE` を手に入れた私は、もう無敵だと思っていました。
1,000行のデータも一瞬で集計できる。リスト処理に死角はない。

しかし、ある日、同僚から頼まれた単純なデータ修正で、手が止まってしまいました。
**「このテキストに入っている『余計なスペース』を全部消してほしいんだ」**

「簡単だよ。`TRIM` 関数か、`SUBSTITUTE` でスペースを空文字に置換すればいい」
そう思ってやってみましたが、データが汚すぎました。

* `"A  B"` (スペース2つ)  1回置換  `"A B"` (OK)
* `"A   B"` (スペース3つ)  1回置換  `"A  B"` (まだ2つ残ってる！)  もう1回置換  `"A B"`

スペースがいくつ連続しているか分からないのです。
VBAなら `Do While` を使って、「スペースが見つからなくなるまで回す」と書くところです。

```vba
Do While InStr(text, "  ") > 0
    text = Replace(text, "  ", " ")
Loop

```

でも、数式には `WHILE` がありません。
`REDUCE` も `MAP` も、「配列の数だけ」回るものであり、「条件を満たすまで」回り続けることはできないのです。

「回数が分からないなら、どうすればいいんだ……？」
悩み抜いた末にたどり着いた答え。それは、**「自分自身を呼び出す」** という常識外れの方法でした。

---

## 1. 鏡の中の自分

関数が、関数の中で自分自身を使う。
これを **「再帰（Recursion）」** と呼びます。

概念としては、こんな会話です。

> **私:** 「このスペースを消して（関数実行）」
> **関数:** 「やってみます。あ、まだスペースが残ってますね。**もう一回、私自身にこの結果を渡して処理させます**」
> **（新しい）関数:** 「受け取りました。やってみます……あ、もうスペースないですね。これで終わりです！」

まるで合わせ鏡のように、処理が終わるまで自分を呼び出し続ける。
これができれば、VBAの `Do While` と同じことができるはずです。

---

## 2. 名前の定義（Name Manager）を使う

LAMBDAで再帰をするには、一つだけルールがあります。
それは、**「自分自身を呼ぶために、自分に名前が付いている必要がある」** ということです。

これまでの `LET` 変数内での定義だけでは、自分自身を参照するのが難しい（循環参照になる）ことが分かりました。
そこで、Excelの**「名前の定義（Ctrl + F3）」**機能を使って、正式に関数を登録することにしました。

名前を **`_全置換`** とし、数式に以下を入力します。

```excel
=LAMBDA(_今の文字,
    IF(
        // 1. 終了条件（もう二重スペースがないなら）
        ISERROR(FIND("  ", _今の文字)),
        
        // そのまま返す（ゴール！）
        _今の文字,
        
        // 2. 再帰呼び出し（まだあるなら）
        // 自分自身(_全置換)を呼び出し、少しきれいになった文字を渡す
        _全置換(SUBSTITUTE(_今の文字, "  ", " "))
    )
)

```

これを登録して、セルに `=_全置換("A     B")` と入力します。
エンターキーを押すと…… `"A B"`。
スペースが5個あろうが100個あろうが、完璧に1つになりました。

動いた……！
関数が、自分の尻尾を食べる蛇（ウロボロス）のようにグルグル回って、仕事を完遂したのです。

---

## 3. 再帰の「2つの掟」

最初は「無限ループしてExcelが固まるんじゃないか？」と怖かったです。
実際、書き方を間違えて何度か固まりました（笑）。

再帰には、絶対に守らなければならない「2つの掟」があることを学びました。

1. **終了条件（Base Case）を書くこと**
「いつ止まるか」を最初に書く。これがないと無限に自分を呼び続けて死にます（スタックオーバーフロー）。
今回の例では `IF(ISERROR(FIND(...)), 終わり, 続く)` がそれです。
2. **問題を小さくして渡すこと**
自分を呼び出すときは、引数が少しだけゴールに近づいている必要があります。
今回は `SUBSTITUTE` でスペースを減らしてから渡していました。これが変化しないままだと、永遠に終わりません。

---

## 4. 応用：文字を分解する（SPLIT）

「条件まで繰り返す」ができるようになると、夢が広がります。
例えば、カンマ区切りのテキスト `"A,B,C,D"` をバラバラの行に分けたい。
（今は `TEXTSPLIT` 関数がありますが、再帰の練習として最高のお題です）

ロジックはこうです。

1. カンマがあるか？
2. あるなら、カンマの手前を切り取って表示し、**残りの部分を自分に渡す。**
3. ないなら、そのまま表示して終了。

```excel
// 名前定義: _SPLIT_ROWS
=LAMBDA(_残りの文字,
    LET(
        _カンマ位置, IFERROR(FIND(",", _残りの文字), 0),
        
        IF(_カンマ位置 = 0,
            // 終了条件：もうカンマがない -> そのまま返す
            _残りの文字,
            
            // 再帰ステップ：
            // 「切り取った部分」と「残りの部分を再帰した結果」を合体(VSTACK)させる
            VSTACK(
                LEFT(_残りの文字, _カンマ位置 - 1),
                _SPLIT_ROWS(MID(_残りの文字, _カンマ位置 + 1, LEN(_残りの文字)))
            )
        )
    )
)

```

これで `_SPLIT_ROWS("A,B,C,D")` と打つと、
A
B
C
D
と縦にスピルします。

「リストを処理する」のではなく、**「処理しながらリストを生成していく」**。
これが再帰のパワーです。

---

## 5. まとめ：プログラミングの「深淵」を覗く

Vol.1 から関数型プログラミングを学んできましたが、この「再帰」こそが最も頭を使いました。
しかし、これを使えば、階層構造のあるデータ（組織図や部品表）を展開したり、複雑なシミュレーションを行ったりすることも可能です。

* **MAP / REDUCE:** 回数が決まっているループ（For）。
* **再帰:** 回数が決まっていないループ（While）。

これで、Excel数式で表現できないロジックは、ほぼなくなりました。

VBAでマクロを組み、ボタンを押して実行していた時代。
今は、セルに数式を書くだけで、リアルタイムに複雑な処理が走ります。

「Excelって、表計算ソフトですよね？」
もし誰かにそう聞かれたら、私は胸を張ってこう答えるでしょう。
**「いいえ、Excelは世界で最も普及している『関数型プログラミング言語』ですよ」** と。

これで、私の「関数型脳」を作る旅は一区切りです。
しかし、数式の探求に終わりはありません。再帰の輪のように、学びは無限に続いていくのですから。

---

### 今日の気づき

* `WHILE` ループがないときは、**「再帰（自分を呼び出す）」** で解決できる。
* 再帰を使うときは、「名前の定義」を使うのが一般的。
* 「終了条件」と「問題を小さくする」ことさえ守れば、無限ループは怖くない。
  
---

# Excelで「関数型脳」を作る Vol.7：創造主になる —— MAPもREDUCEも、再帰で作れる

前回、私は「条件を満たすまで自分を呼び出す（再帰）」という禁断の秘儀を習得しました。
これで `WHILE` ループがなくても生きていけます。

しかし、ふと恐ろしい疑問が頭をよぎりました。
「待てよ。`MAP` や `REDUCE` って、内部では何をやっているんだ？」

`MAP` は、リストの先頭から順に処理をしていく。
`REDUCE` は、リストの先頭から順に雪だるま式に計算していく。

これって……
**「リストが空になるまで、自分自身を呼び出し続ける」**
という、再帰そのものではないでしょうか？

もしこの仮説が正しければ、Excelに `MAP` 関数が搭載されていなくても、`LAMBDA` と再帰さえあれば、**自分で `MAP` を再発明できる** ということになります。

第7章のテーマは、**「車輪の再発明」**。
あえて便利な道具（標準関数）を捨て、原子レベルのロジック（再帰）から世界を再構築してみます。

---

## 1. そもそもリスト処理とは何か？

再帰を使ってリストを処理するには、リストを「2つ」に分解する発想が必要です。

1. **先頭（Head）：** 今すぐ処理すべき「1つ目の要素」。
2. **残り（Tail）：** 後で処理すべき「残りのリスト」。

`MAP` の動きを、再帰的に翻訳してみましょう。

* **命令型（For）：** 「i番目の要素を処理せよ」
* **再帰的定義：**
1. まず、「先頭」を関数で処理する。
2. そして、「残り」に対して、また自分自身（MAP）を実行する。
3. 最後に、1と2の結果をくっつける（スタックする）。
4. ただし、「残り」がなくなったら終了する。



このロジック通りに書けば、本当に動くはずです。

---

## 2. 実験：`MY_MAP` を自作する

では、標準の `MAP` 関数を使わずに、自作の `_オレオレMAP` を定義してみましょう。
リスト操作には `TAKE`（先頭取得）と `DROP`（残り取得）、そして `VSTACK`（合体）を使います。

```excel
// 名前定義: _MY_MAP
=LAMBDA(_リスト, _関数,
    LET(
        _件数, ROWS(_リスト),
        
        // --- 1. 終了条件（Base Case） ---
        IF(_件数 = 0,
            "",  // リストが空なら終了
            
            // --- 2. 再帰ステップ（Recursive Step） ---
            LET(
                _先頭, TAKE(_リスト, 1),      // Head: 最初の1個
                _残り, DROP(_リスト, 1),      // Tail: 残りの全部
                
                VSTACK(
                    _関数(_先頭),             // 先頭を処理して...
                    _MY_MAP(_残り, _関数)     // 残りに対して自分を呼ぶ！
                )
            )
        )
    )
)

```

これをセルで実行してみます。
`=_MY_MAP(A1:A3, LAMBDA(x, x * 2))`

……動きました！
A1:A3 の値がすべて2倍されてスピルしました。

震えました。
私は今、Microsoftが提供してくれた機能をただ使うだけのユーザーから、**機能そのものを作り出すエンジニア**へと進化しました。
再帰とは、単なるループの代わりではなく、**「あらゆる繰り返し処理の原点（原子）」** だったのです。

---

## 3. 最強の `MY_REDUCE` も自作する

`MAP` が作れるなら、ラスボスの `REDUCE` も作れるはずです。
`REDUCE` の本質は「状態（雪だるま）」を引き継ぐことでした。

再帰のロジックはこうなります。

1. 「現在の雪だるま」と「先頭」を合体させて、「新しい雪だるま」を作る。
2. 「新しい雪だるま」と「残り」を持って、自分自身（REDUCE）を呼ぶ。
3. 「残り」がなくなったら、雪だるまを返して終了。

```excel
// 名前定義: _MY_REDUCE
=LAMBDA(_雪だるま, _リスト, _関数,
    LET(
        _件数, ROWS(_リスト),
        
        // --- 1. 終了条件 ---
        IF(_件数 = 0,
            _雪だるま,  // リストが空になったら、完成した雪だるまを返す
            
            // --- 2. 再帰ステップ ---
            LET(
                _先頭, TAKE(_リスト, 1),
                _残り, DROP(_リスト, 1),
                
                // 新しい雪だるまを作って、次へ渡す
                _新しい雪だるま, _関数(_雪だるま, _先頭),
                
                _MY_REDUCE(_新しい雪だるま, _残り, _関数)
            )
        )
    )
)

```

これも完璧に動作しました。
`SUM` も `TEXTJOIN` も、すべてこの `_MY_REDUCE` ひとつで再現できます。

---

## 4. 再帰は「万能の型」である

この実験で分かったことがあります。
`MAP` も `FILTER` も `REDUCE` も、別々の機能に見えて、実はすべて **「再帰（リストの分解と合成）」** という一つの仕組みのバリエーションに過ぎないということです。

* **MAP:** 処理して、結果を積み上げる再帰。
* **FILTER:** 条件に合う時だけ、結果を積み上げる再帰。
* **REDUCE:** 結果を積み上げずに、一つに練り込んでいく再帰。

これを知ってしまった今、Excelの数式バーが、無限の可能性を持ったキャンバスに見えます。
もし将来、Excelにまだない「未知のデータ処理関数」が必要になっても、私はもう困りません。
**再帰を使えば、自分で作れるからです。**

---

## 5. シリーズまとめ：Excelでプログラミングの本質へ

Vol.1 から Vol.7 まで、Excel LAMBDA を通して「関数型プログラミング」の世界を旅してきました。

1. **代入をやめ、定義する**（不変性）
2. **関数を値として扱う**（第一級関数）
3. **部分適用で道具を作る**（カリー化）
4. **リストを一括処理する**（高階関数 MAP/FILTER）
5. **状態を畳み込む**（集計 REDUCE/SCAN）
6. **自分を呼び出す**（単純な再帰）
7. **仕組みを再発明する**（再帰による抽象化）

これらは、流行りのPythonやJavaScriptを学ぶ上でも、最も重要でつまずきやすい概念です。
それを、使い慣れたExcelの上で、セルという目に見える箱を使って体感できたことは、私のエンジニア人生にとって最大の財産になりました。

「Excel方眼紙」と揶揄されることもあるこのツール。
しかし、その奥底には、美しく強力な**「計算の理論（ラムダ計算）」**が眠っていました。

さあ、これからは自信を持って使いましょう。
単なる表計算ではなく、**「思考を関数として定義し、データを流す」** という新しいスタイルを。

あなたの「関数型脳」は、もう完成しています。

**(完)**

---

### 今日の気づき（最終回）

* `MAP` や `REDUCE` は魔法のブラックボックスではなく、**「再帰」** で作られた仕組みだった。
* リスト処理の基本は **「先頭（Head）」と「残り（Tail）」** に分解すること。
* 再帰をマスターすれば、言語に用意されていない機能さえも、自分の手で創造できる。

---

# Excelで「関数型脳」を作る Vol.7：名前はいらない —— 無名再帰と不動点コンビネータ

前回、私は「名前の定義」を使って再帰を行い、`WHILE` ループを再現しました。
これで完璧だと思いました。しかし、このファイルを同僚に渡したとき、悲劇が起きました。

「シートをコピーしたら、数式が `#NAME?` エラーになるんだけど？」

原因は**「名前の定義（Name Manager）」**です。
名前定義はブック単位やシート単位で管理されるため、数式だけをコピペしても、裏側にある「定義」がついてこないのです。

「数式をセルに書くだけで完結させたい」
「名前定義なんていう『設定』に依存したくない」

そのためには、**「名前のない関数（LAMBDA）」が、自分自身を呼び出す**必要があります。
しかし、名前がないのに、どうやって「自分」を呼べばいいのでしょう？

第7章のテーマは、**「無名再帰」**。
プログラミング理論の伝説、**Yコンビネータ（不動点コンビネータ）** に挑みます。

---

## 1. 矛盾：「私」を呼ぶ名前がない

通常の再帰はこうでした。

```excel
// 名前: _Rec
=LAMBDA(n, ... _Rec(n-1) ...)

```

これなら `_Rec` という看板を目指して戻ってこれます。
しかし、セルに直接書く「無名LAMBDA」には看板がありません。

```excel
=LAMBDA(n, ... ???(n-1) ...)

```

`???` に入れるものがないのです。
ここで私は、あるクレイジーなアイデアを思いつきました。

**「自分自身を、引数として渡してしまえばいいんじゃないか？」**

つまり、「自分自身の設計図」を、自分の中に取り込んで実行するのです。

---

## 2. 自分を引数にする

「階乗（）」を例に実験してみます。
まず、再帰したいロジックを書きます。ただし、自分を呼ぶための引数 `_myself` を余分に用意します。

```excel
=LAMBDA(_myself, _n,
    IF(_n = 1, 
        1,
        _n * _myself(_myself, _n - 1)  // ← ここで自分自身(_myself)に、自分(_myself)を渡す！
    )
)

```

この関数自体を変数 `_Logic` に入れて、実行してみます。

```excel
=LET(
    _Logic, LAMBDA(_myself, _n, IF(_n=1, 1, _n * _myself(_myself, _n-1))),
    
    // 最初の呼び出し：自分自身(_Logic)を第1引数として渡す
    _Logic(_Logic, 5)
)

```

動きました！ 結果は `120`。
名前定義なし、セルの中だけで完結する再帰の完成です。

しかし……数式を見てください。
`_n * _myself(_myself, _n - 1)`
「自分に自分を渡す」という記述が、ロジックの中に混ざり込んでいて、非常に美しくありません。
これでは、ただでさえ複雑な再帰ロジックがスパゲッティになってしまいます。

---

## 3. 魔法の鏡「コンビネータ」を作る

ここで、先人たちの知恵を借ります。
この「自分を自分に渡す」という面倒な手続きを、**自動でやってくれる装置** が発明されているのです。

それを **「不動点コンビネータ（Fixed Point Combinator）」** と呼びます。
一般的には「Yコンビネータ」として有名ですが、Excelのような「引数を先に評価する言語（正格評価）」では、少し改良した **「Zコンビネータ」** を使います。

難しい数学の話は抜きにして、これがその「魔法の数式」です。

```excel
// Zコンビネータ（無名再帰を実現する魔法の部品）
LAMBDA(_f, 
    LET(
        _x, LAMBDA(_x, _f(LAMBDA(_y, _x(_x)(_y)))),
        _x(_x)
    )
)

```

「うわっ、わけがわからない」
大丈夫です。中身を理解する必要はありません。
これは**「USB変換アダプタ」**のようなものです。
これを通すと、普通の書き方で書いた関数が、勝手に再帰できるようになるのです。

---

## 4. コンビネータを使ってみる

では、この魔法のアダプタを使って、階乗計算を書き直してみましょう。

**ステップ1：ロジックを書く**
普通の再帰と同じように書きます。ただし、第1引数 `_myFunc` は「再帰用の関数」が入ってくると信じて書きます。
（さっきのように `_myFunc(_myFunc, ...)` と書く必要はありません！）

```excel
// ロジック（中身）
LAMBDA(_myFunc, _n,
    IF(_n = 1, 1, _n * _myFunc(_n - 1))
)

```

**ステップ2：コンビネータと合体させる**
`LET` を使って、アダプタ（`_Y`）を定義し、それにロジックを渡します。

```excel
=LET(
    // 1. 魔法のアダプタ（Zコンビネータ）を定義 ※コピペでOK
    _Y, LAMBDA(_f, LET(_x, LAMBDA(_x, _f(LAMBDA(_y, _x(_x)(_y)))), _x(_x))),
    
    // 2. やりたい処理ロジックを定義
    // 第1引数(_rec)は「再帰呼び出し」として使う
    _Factorial, _Y(
        LAMBDA(_rec, _n,
            IF(_n = 1, 1, _n * _rec(_n - 1))
        )
    ),
    
    // 3. 実行
    _Factorial(5)
)

```

結果：`120`。
見てください。ロジック部分（`_Factorial` の中身）は、`_n * _rec(_n - 1)` と非常にすっきりしています。
「自分を渡す」という泥臭い作業は、すべて `_Y` が裏で引き受けてくれました。

---

## 5. 無名再帰で `MAP` を再発明する

これを使えば、Vol.6で作った `MY_MAP`（自作MAP）も、名前定義なしでセルの中に記述できます。

```excel
=LET(
    // 魔法のアダプタ
    _Y, LAMBDA(_f, LET(_x, LAMBDA(_x, _f(LAMBDA(_y, _x(_x)(_y)))), _x(_x))),

    // MAPを自作（無名再帰バージョン）
    _MY_MAP, _Y(
        LAMBDA(_rec, _list, 
            LET(
                _count, ROWS(_list),
                IF(_count = 0, "",
                    VSTACK(
                        // 先頭を2倍にする処理（※ここを好きな処理に変える）
                        TAKE(_list, 1) * 2,
                        // 残りを再帰
                        _rec(DROP(_list, 1))
                    )
                )
            )
        )
    ),

    _MY_MAP(A1:A3)
)

```

この数式には、依存関係が一切ありません。
このセルをコピーして、別のブックの、別のシートの、どこに貼り付けても動きます。
**「完全なポータビリティ（移植性）」** を持った、最強の数式です。

---

## 6. まとめ：数式の「美しさ」を知る

最初は「名前定義が面倒だから」という理由で無名再帰を探し始めました。
しかし、たどり着いた「Y（Z）コンビネータ」は、プログラミングの歴史の中でも特に美しいとされる数式でした。

* **名前付き再帰:** 分かりやすいが、環境（名前定義）に依存する。
* **無名再帰（コンビネータ）:** 数式が複雑になるが、環境に依存せずどこでも動く。

実務的には、チームで共有するなら「名前付き再帰」の方が可読性が高いかもしれません。
しかし、「たった一つのセルに全宇宙を詰め込みたい」というギークな欲望を満たすには、このコンビネータこそが最高の道具です。

さて、これで本当に道具は揃いました。
名前も、ループも、環境設定さえもいらない。
あるのは **LAMBDA** という純粋な論理だけ。

次回、最終回。
これまでの全てを統合し、Excel関数型プログラミングの総決算を行います。
**Vol.8「終わりの始まり —— ラムダ計算とExcelの未来」**。

---

### 今日の気づき

* 「名前の定義」を使わないと再帰できないと思っていたが、**「自分を引数にする」**ことで解決できた。
* **「Zコンビネータ」** という定型文（魔法のアダプタ）を使えば、無名再帰もきれいに書ける。
* これにより、どのブックにもコピペできる「ポータブルな再帰関数」が作れるようになった。

